<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MAX32680 Peripheral Driver API: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MI_Logo_Small_Pos_RGB_150dpi.png"/></td>
  <td id="projectalign">
   <div id="projectname">MAX32680 Peripheral Driver API
   </div>
   <div id="projectbrief">Peripheral Driver API for the MAX32680</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__i2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">I2C</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__i2c__registers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__registers.html">I2C_Registers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct__i2c__req__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#struct__i2c__req__t">mxc_i2c_req_t</a></td></tr>
<tr class="separator:struct__i2c__req__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga85bcf9166313c7a5abe995f795bdffe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga85bcf9166313c7a5abe995f795bdffe1">mxc_i2c_getAck_t</a>) (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char byte)</td></tr>
<tr class="separator:ga85bcf9166313c7a5abe995f795bdffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561edd8f16d614d5d2065eb1552c9e4e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga561edd8f16d614d5d2065eb1552c9e4e">mxc_i2c_complete_cb_t</a>) (mxc_i2c_req_t *req, int result)</td></tr>
<tr class="separator:ga561edd8f16d614d5d2065eb1552c9e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebe328315d28a4364eeb630b66ef738"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaeebe328315d28a4364eeb630b66ef738">mxc_i2c_dma_complete_cb_t</a>) (int len, int result)</td></tr>
<tr class="separator:gaeebe328315d28a4364eeb630b66ef738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ece424b8dcaa21b765af1e9b84148d7"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga5ece424b8dcaa21b765af1e9b84148d7">mxc_i2c_slave_handler_t</a>) (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, <a class="el" href="group__i2c.html#ga77a60c635f64412b0e4adb5d0337f5a1">mxc_i2c_slave_event_t</a> event, void *data)</td></tr>
<tr class="separator:ga5ece424b8dcaa21b765af1e9b84148d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga77a60c635f64412b0e4adb5d0337f5a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga77a60c635f64412b0e4adb5d0337f5a1">mxc_i2c_slave_event_t</a> </td></tr>
<tr class="separator:ga77a60c635f64412b0e4adb5d0337f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaffa36a7ab08e0f222bb7a9c305d2eca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaffa36a7ab08e0f222bb7a9c305d2eca6">MXC_I2C_Init</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, int masterMode, unsigned int slaveAddr)</td></tr>
<tr class="separator:gaffa36a7ab08e0f222bb7a9c305d2eca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c032adb3aca741cb77d4c5e14d65e60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga4c032adb3aca741cb77d4c5e14d65e60">MXC_I2C_SetSlaveAddr</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int slaveAddr, int idx)</td></tr>
<tr class="separator:ga4c032adb3aca741cb77d4c5e14d65e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e85aeb2f25b27b1049b8519dad9276"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga98e85aeb2f25b27b1049b8519dad9276">MXC_I2C_Shutdown</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga98e85aeb2f25b27b1049b8519dad9276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dceaa8c080edde5acf5bece9b054ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gae0dceaa8c080edde5acf5bece9b054ba">MXC_I2C_Reset</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gae0dceaa8c080edde5acf5bece9b054ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c6eb650f273bdd2ecd472d214a4457"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga77c6eb650f273bdd2ecd472d214a4457">MXC_I2C_SetFrequency</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int hz)</td></tr>
<tr class="separator:ga77c6eb650f273bdd2ecd472d214a4457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b7dced5e6c9a0cb98c9f4996bd221e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gab0b7dced5e6c9a0cb98c9f4996bd221e">MXC_I2C_GetFrequency</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gab0b7dced5e6c9a0cb98c9f4996bd221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b8d13c97bf73d1e4c0ee5e631d0f7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gad4b8d13c97bf73d1e4c0ee5e631d0f7f">MXC_I2C_ReadyForSleep</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gad4b8d13c97bf73d1e4c0ee5e631d0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35511bf2fd8213685ba6202b8b81929b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga35511bf2fd8213685ba6202b8b81929b">MXC_I2C_SetClockStretching</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, int enable)</td></tr>
<tr class="separator:ga35511bf2fd8213685ba6202b8b81929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913e7debd6310460beba186cd4eb2712"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga913e7debd6310460beba186cd4eb2712">MXC_I2C_GetClockStretching</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga913e7debd6310460beba186cd4eb2712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe385d2386e3828c8ee1843eefb2bdb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gabe385d2386e3828c8ee1843eefb2bdb8">MXC_I2C_Start</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gabe385d2386e3828c8ee1843eefb2bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b23466f882ed573b26bf35fae91684f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga4b23466f882ed573b26bf35fae91684f">MXC_I2C_Stop</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga4b23466f882ed573b26bf35fae91684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ce8ba5d7da2e0bcb768d3883d01388"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga08ce8ba5d7da2e0bcb768d3883d01388">MXC_I2C_WriteByte</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char byte)</td></tr>
<tr class="separator:ga08ce8ba5d7da2e0bcb768d3883d01388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e49207ae370498dde9d6c4d4165ca1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga89e49207ae370498dde9d6c4d4165ca1">MXC_I2C_ReadByte</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *byte, int ack)</td></tr>
<tr class="separator:ga89e49207ae370498dde9d6c4d4165ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01baf34328478818eb530a0942050593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga01baf34328478818eb530a0942050593">MXC_I2C_ReadByteInteractive</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *byte, <a class="el" href="group__i2c.html#ga85bcf9166313c7a5abe995f795bdffe1">mxc_i2c_getAck_t</a> getAck)</td></tr>
<tr class="separator:ga01baf34328478818eb530a0942050593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef10e74237bebc99697454754fa2cc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga9ef10e74237bebc99697454754fa2cc5">MXC_I2C_Write</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *bytes, unsigned int *len)</td></tr>
<tr class="separator:ga9ef10e74237bebc99697454754fa2cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ffe81c19cde38ab2d4e0637e72a6be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gab1ffe81c19cde38ab2d4e0637e72a6be">MXC_I2C_Read</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *bytes, unsigned int *len, int ack)</td></tr>
<tr class="separator:gab1ffe81c19cde38ab2d4e0637e72a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe47d2f744cd5cc0e29b1193d6e634fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gafe47d2f744cd5cc0e29b1193d6e634fe">MXC_I2C_ReadRXFIFO</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, volatile unsigned char *bytes, unsigned int len)</td></tr>
<tr class="separator:gafe47d2f744cd5cc0e29b1193d6e634fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8dfe0eeb7a171a932db7a494aec59f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga2f8dfe0eeb7a171a932db7a494aec59f">MXC_I2C_ReadRXFIFODMA</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *bytes, unsigned int len, <a class="el" href="group__i2c.html#gaeebe328315d28a4364eeb630b66ef738">mxc_i2c_dma_complete_cb_t</a> callback)</td></tr>
<tr class="separator:ga2f8dfe0eeb7a171a932db7a494aec59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102491bfd8c3c184104b72f9818049d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga102491bfd8c3c184104b72f9818049d3">MXC_I2C_GetRXFIFOAvailable</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga102491bfd8c3c184104b72f9818049d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0cf9728326a2b8ecded92970c4203a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gab0cf9728326a2b8ecded92970c4203a6">MXC_I2C_WriteTXFIFO</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, volatile unsigned char *bytes, unsigned int len)</td></tr>
<tr class="separator:gab0cf9728326a2b8ecded92970c4203a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff38fb85b10d703e0013550ea990bf5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaff38fb85b10d703e0013550ea990bf5c">MXC_I2C_WriteTXFIFODMA</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char *bytes, unsigned int len, <a class="el" href="group__i2c.html#gaeebe328315d28a4364eeb630b66ef738">mxc_i2c_dma_complete_cb_t</a> callback)</td></tr>
<tr class="separator:gaff38fb85b10d703e0013550ea990bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae59db133ca586c021568cb92a0b1bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga2ae59db133ca586c021568cb92a0b1bc">MXC_I2C_GetTXFIFOAvailable</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga2ae59db133ca586c021568cb92a0b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e05ef461feb962f032ff7a4b2a35456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga4e05ef461feb962f032ff7a4b2a35456">MXC_I2C_ClearRXFIFO</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga4e05ef461feb962f032ff7a4b2a35456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac5558ec91a3d434f13b67596cd9864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga5ac5558ec91a3d434f13b67596cd9864">MXC_I2C_ClearTXFIFO</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga5ac5558ec91a3d434f13b67596cd9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9c710601045d2b56aa72a9d245582f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga9b9c710601045d2b56aa72a9d245582f">MXC_I2C_GetFlags</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int *flags0, unsigned int *flags1)</td></tr>
<tr class="separator:ga9b9c710601045d2b56aa72a9d245582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ad14f32660186f7ba6cf1b4bdd3068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga15ad14f32660186f7ba6cf1b4bdd3068">MXC_I2C_ClearFlags</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int flags0, unsigned int flags1)</td></tr>
<tr class="separator:ga15ad14f32660186f7ba6cf1b4bdd3068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3191ddeb97b19c0c103ad9e78c1f12c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga3191ddeb97b19c0c103ad9e78c1f12c9">MXC_I2C_EnableInt</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int flags0, unsigned int flags1)</td></tr>
<tr class="separator:ga3191ddeb97b19c0c103ad9e78c1f12c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc27ac288f41d583048b9f90cf8aebd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gadc27ac288f41d583048b9f90cf8aebd9">MXC_I2C_DisableInt</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int flags0, unsigned int flags1)</td></tr>
<tr class="separator:gadc27ac288f41d583048b9f90cf8aebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7915d0d8a68ee5dc3c6bdf3becd8a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gae7915d0d8a68ee5dc3c6bdf3becd8a62">MXC_I2C_EnablePreload</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gae7915d0d8a68ee5dc3c6bdf3becd8a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d80b18ac960c15b428533c3a029cec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga1d80b18ac960c15b428533c3a029cec7">MXC_I2C_DisablePreload</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga1d80b18ac960c15b428533c3a029cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bfbcf321baaf94f79712c2f1e422a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga53bfbcf321baaf94f79712c2f1e422a5">MXC_I2C_EnableGeneralCall</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga53bfbcf321baaf94f79712c2f1e422a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63aab1fcc4e60971532b8b6dcf9f2037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga63aab1fcc4e60971532b8b6dcf9f2037">MXC_I2C_DisableGeneralCall</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga63aab1fcc4e60971532b8b6dcf9f2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae88d5d2cf476809b522728a0c0d119f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaae88d5d2cf476809b522728a0c0d119f">MXC_I2C_SetTimeout</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int timeout)</td></tr>
<tr class="separator:gaae88d5d2cf476809b522728a0c0d119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be643c85c4916d9a8c2d3275ff38a30"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga2be643c85c4916d9a8c2d3275ff38a30">MXC_I2C_GetTimeout</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga2be643c85c4916d9a8c2d3275ff38a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e7832da2a21d8b456af63e24ce36ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gab4e7832da2a21d8b456af63e24ce36ca">MXC_I2C_Recover</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int retries)</td></tr>
<tr class="separator:gab4e7832da2a21d8b456af63e24ce36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6609599fffe5affbd589dd81f11aeed2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga6609599fffe5affbd589dd81f11aeed2">MXC_I2C_MasterTransaction</a> (mxc_i2c_req_t *req)</td></tr>
<tr class="separator:ga6609599fffe5affbd589dd81f11aeed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757bef5ee0c5cae8ba88370746ca3715"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga757bef5ee0c5cae8ba88370746ca3715">MXC_I2C_MasterTransactionAsync</a> (mxc_i2c_req_t *req)</td></tr>
<tr class="separator:ga757bef5ee0c5cae8ba88370746ca3715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59f39c18ce6f0cb09703515734d6422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gab59f39c18ce6f0cb09703515734d6422">MXC_I2C_MasterTransactionDMA</a> (mxc_i2c_req_t *req)</td></tr>
<tr class="separator:gab59f39c18ce6f0cb09703515734d6422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037f5f639895fb5305d05f1f8a975ddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga037f5f639895fb5305d05f1f8a975ddb">MXC_I2C_SlaveTransaction</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, <a class="el" href="group__i2c.html#ga5ece424b8dcaa21b765af1e9b84148d7">mxc_i2c_slave_handler_t</a> callback)</td></tr>
<tr class="separator:ga037f5f639895fb5305d05f1f8a975ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71992198c387effdb887ace75d2b40c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga71992198c387effdb887ace75d2b40c7">MXC_I2C_SlaveTransactionAsync</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, <a class="el" href="group__i2c.html#ga5ece424b8dcaa21b765af1e9b84148d7">mxc_i2c_slave_handler_t</a> callback)</td></tr>
<tr class="separator:ga71992198c387effdb887ace75d2b40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f96f30ffcaf5f775773e36faac3b1e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga0f96f30ffcaf5f775773e36faac3b1e3">MXC_I2C_SetRXThreshold</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int numBytes)</td></tr>
<tr class="separator:ga0f96f30ffcaf5f775773e36faac3b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf888560e606dd4cb1fe3bab90c06756"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaaf888560e606dd4cb1fe3bab90c06756">MXC_I2C_GetRXThreshold</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gaaf888560e606dd4cb1fe3bab90c06756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb55e2af2b42c66e9da1d12c71f8d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gacbb55e2af2b42c66e9da1d12c71f8d2c">MXC_I2C_SetTXThreshold</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned int numBytes)</td></tr>
<tr class="separator:gacbb55e2af2b42c66e9da1d12c71f8d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f521e2c112fee74366b5be8af48662"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gae3f521e2c112fee74366b5be8af48662">MXC_I2C_GetTXThreshold</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gae3f521e2c112fee74366b5be8af48662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb51adbf4b889de2aa48892aa525dfc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gadb51adbf4b889de2aa48892aa525dfc5">MXC_I2C_AsyncStop</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gadb51adbf4b889de2aa48892aa525dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92648a55c0b2b94b99e81fc1b2fb4f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ga92648a55c0b2b94b99e81fc1b2fb4f48">MXC_I2C_AbortAsync</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:ga92648a55c0b2b94b99e81fc1b2fb4f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3fc7633faccfdc8bfd2e662155d4190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gaf3fc7633faccfdc8bfd2e662155d4190">MXC_I2C_AsyncHandler</a> (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c)</td></tr>
<tr class="separator:gaf3fc7633faccfdc8bfd2e662155d4190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada949222dbe550f528f7a52fd19b7723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#gada949222dbe550f528f7a52fd19b7723">MXC_I2C_DMACallback</a> (int ch, int error)</td></tr>
<tr class="separator:gada949222dbe550f528f7a52fd19b7723"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct__i2c__req__t" id="struct__i2c__req__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct__i2c__req__t">&#9670;&nbsp;</a></span>_i2c_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct _i2c_req_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >The information required to perform a complete I2C transaction as the bus master. </p>
<p >The information required to perform a complete I2C transaction as the bus master. This structure is used by the <a class="el" href="group__i2c.html#ga6609599fffe5affbd589dd81f11aeed2" title="Performs a blocking I2C master transaction.">MXC_I2C_MasterTransaction()</a> and <a class="el" href="group__i2c.html#ga757bef5ee0c5cae8ba88370746ca3715" title="Performs a non-blocking I2C master transaction.">MXC_I2C_MasterTransactionAsync()</a> functions. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ac3fac1949b2dff1219bd757c4571b52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ac3fac1949b2dff1219bd757c4571b52c">i2c</a></td></tr>
<tr class="separator:ac3fac1949b2dff1219bd757c4571b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36863a07751ac73459d46b677c33b57"><td class="memItemLeft" align="right" valign="top"><a id="ab36863a07751ac73459d46b677c33b57" name="ab36863a07751ac73459d46b677c33b57"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>addr</b></td></tr>
<tr class="separator:ab36863a07751ac73459d46b677c33b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1e595f5ac351991634b247bd470b0a"><td class="memItemLeft" align="right" valign="top"><a id="aaa1e595f5ac351991634b247bd470b0a" name="aaa1e595f5ac351991634b247bd470b0a"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>tx_buf</b></td></tr>
<tr class="separator:aaa1e595f5ac351991634b247bd470b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8559300006eda5958ac86551a6ff8cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#ab8559300006eda5958ac86551a6ff8cd">tx_len</a></td></tr>
<tr class="separator:ab8559300006eda5958ac86551a6ff8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d96b3e83f506af2c4c5c1ddfd3c785"><td class="memItemLeft" align="right" valign="top"><a id="a62d96b3e83f506af2c4c5c1ddfd3c785" name="a62d96b3e83f506af2c4c5c1ddfd3c785"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>rx_buf</b></td></tr>
<tr class="separator:a62d96b3e83f506af2c4c5c1ddfd3c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a4ab0355b90b84277c05f75119f55"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#a7d1a4ab0355b90b84277c05f75119f55">rx_len</a></td></tr>
<tr class="separator:a7d1a4ab0355b90b84277c05f75119f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebd0610b02b8fad4f28c6deadea0c7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#a9ebd0610b02b8fad4f28c6deadea0c7d">restart</a></td></tr>
<tr class="separator:a9ebd0610b02b8fad4f28c6deadea0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7f97913840e84de65f992fb6828a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__i2c.html#ga561edd8f16d614d5d2065eb1552c9e4e">mxc_i2c_complete_cb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c.html#a5c7f97913840e84de65f992fb6828a24">callback</a></td></tr>
<tr class="separator:a5c7f97913840e84de65f992fb6828a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a5c7f97913840e84de65f992fb6828a24" name="a5c7f97913840e84de65f992fb6828a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7f97913840e84de65f992fb6828a24">&#9670;&nbsp;</a></span>callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__i2c.html#ga561edd8f16d614d5d2065eb1552c9e4e">mxc_i2c_complete_cb_t</a> callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The callback used to indicate the transaction is complete or an error has occurred. This field may be set to NULL if no indication is necessary. This field is only used by the <a class="el" href="group__i2c.html#ga757bef5ee0c5cae8ba88370746ca3715" title="Performs a non-blocking I2C master transaction.">MXC_I2C_MasterTransactionAsync()</a> function. <a class="el" href="group__i2c.html#ga6609599fffe5affbd589dd81f11aeed2" title="Performs a blocking I2C master transaction.">MXC_I2C_MasterTransaction()</a> ignores the callback field. </p>

</div>
</div>
<a id="ac3fac1949b2dff1219bd757c4571b52c" name="ac3fac1949b2dff1219bd757c4571b52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fac1949b2dff1219bd757c4571b52c">&#9670;&nbsp;</a></span>i2c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a>* i2c</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C block used.) </p>
<p >Pointer to I2C registers (selects the </p>

</div>
</div>
<a id="a9ebd0610b02b8fad4f28c6deadea0c7d" name="a9ebd0610b02b8fad4f28c6deadea0c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebd0610b02b8fad4f28c6deadea0c7d">&#9670;&nbsp;</a></span>restart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int restart</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Controls whether the transaction is terminated with a stop or repeated start condition. Use 0 for a stop, non-zero for repeated start. </p>

</div>
</div>
<a id="a7d1a4ab0355b90b84277c05f75119f55" name="a7d1a4ab0355b90b84277c05f75119f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a4ab0355b90b84277c05f75119f55">&#9670;&nbsp;</a></span>rx_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rx_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of bytes to read. On return from the function, this will be set to the number of bytes actually received. </p>

</div>
</div>
<a id="ab8559300006eda5958ac86551a6ff8cd" name="ab8559300006eda5958ac86551a6ff8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8559300006eda5958ac86551a6ff8cd">&#9670;&nbsp;</a></span>tx_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tx_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of bytes to write. On return from the function, this will be set to the number of bytes actually transmitted. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga561edd8f16d614d5d2065eb1552c9e4e" name="ga561edd8f16d614d5d2065eb1552c9e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga561edd8f16d614d5d2065eb1552c9e4e">&#9670;&nbsp;</a></span>mxc_i2c_complete_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mxc_i2c_complete_cb_t) (mxc_i2c_req_t *req, int result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback routine used by the <a class="el" href="group__i2c.html#ga757bef5ee0c5cae8ba88370746ca3715" title="Performs a non-blocking I2C master transaction.">MXC_I2C_MasterTransactionAsync()</a> function to indicate the transaction has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The details of the transaction. </td></tr>
    <tr><td class="paramname">result</td><td>0 if all bytes are acknowledged, 1 if any byte transmitted is not acknowledged, negative if error. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error codes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeebe328315d28a4364eeb630b66ef738" name="gaeebe328315d28a4364eeb630b66ef738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeebe328315d28a4364eeb630b66ef738">&#9670;&nbsp;</a></span>mxc_i2c_dma_complete_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mxc_i2c_dma_complete_cb_t) (int len, int result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback routine used by the I2C Read/Write FIFO DMA functions to indicate the transaction has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of data actually read/written </td></tr>
    <tr><td class="paramname">result</td><td>See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error codes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85bcf9166313c7a5abe995f795bdffe1" name="ga85bcf9166313c7a5abe995f795bdffe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85bcf9166313c7a5abe995f795bdffe1">&#9670;&nbsp;</a></span>mxc_i2c_getAck_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* mxc_i2c_getAck_t) (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, unsigned char byte)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback used by the <a class="el" href="group__i2c.html#ga01baf34328478818eb530a0942050593" title="Read a single byte from the I2C bus.">MXC_I2C_ReadByteInteractive()</a> function. </p>
<p >The callback routine used by the <a class="el" href="group__i2c.html#ga01baf34328478818eb530a0942050593" title="Read a single byte from the I2C bus.">MXC_I2C_ReadByteInteractive()</a> function. This function allows the application to determine whether the byte received should be acknowledged or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">byte</td><td>The byte received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the byte should not be acknowledged (NACK), non-zero to acknowledge the byte. </dd></dl>

</div>
</div>
<a id="ga5ece424b8dcaa21b765af1e9b84148d7" name="ga5ece424b8dcaa21b765af1e9b84148d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ece424b8dcaa21b765af1e9b84148d7">&#9670;&nbsp;</a></span>mxc_i2c_slave_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* mxc_i2c_slave_handler_t) (<a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *i2c, <a class="el" href="group__i2c.html#ga77a60c635f64412b0e4adb5d0337f5a1">mxc_i2c_slave_event_t</a> event, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback routine used by the <a class="el" href="group__i2c.html#ga037f5f639895fb5305d05f1f8a975ddb" title="Performs a blocking I2C slave transaction.">MXC_I2C_SlaveTransaction()</a> and MXC_I2C_SlaveTransactionAsync functions to handle the various I2C slave events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">event</td><td>The event that occurred to trigger this callback. </td></tr>
    <tr><td class="paramname">data</td><td>This field is used to pass Success/Fail for the MXC_I2C_EVT_TRANS_COMP event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is only used in the case of an MXC_I2C_EVT_RX_THRESH event. In this case, the return specifies if the last byte received should be acknowledged or not. Return 0 to acknowledge, non-zero to not acknowledge. The return value is ignored for all other event types. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga77a60c635f64412b0e4adb5d0337f5a1" name="ga77a60c635f64412b0e4adb5d0337f5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a60c635f64412b0e4adb5d0337f5a1">&#9670;&nbsp;</a></span>mxc_i2c_slave_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c.html#ga77a60c635f64412b0e4adb5d0337f5a1">mxc_i2c_slave_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of events reported by the <a class="el" href="group__i2c.html#ga037f5f639895fb5305d05f1f8a975ddb" title="Performs a blocking I2C slave transaction.">MXC_I2C_SlaveTransaction()</a> and <a class="el" href="group__i2c.html#ga71992198c387effdb887ace75d2b40c7" title="Performs a non-blocking I2C slave transaction.">MXC_I2C_SlaveTransactionAsync()</a> functions. </p>
<p >The list of events reported by the <a class="el" href="group__i2c.html#ga037f5f639895fb5305d05f1f8a975ddb" title="Performs a blocking I2C slave transaction.">MXC_I2C_SlaveTransaction()</a> and <a class="el" href="group__i2c.html#ga71992198c387effdb887ace75d2b40c7" title="Performs a non-blocking I2C slave transaction.">MXC_I2C_SlaveTransactionAsync()</a> functions. It is up to the calling application to handle these events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1adb561921ad40ff68190266e861fed728" name="gga77a60c635f64412b0e4adb5d0337f5a1adb561921ad40ff68190266e861fed728"></a>MXC_I2C_EVT_MASTER_WR&#160;</td><td class="fielddoc"><p >requesting a write to the slave. </p>
<p >A slave address match occurred with the master </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1adc39f393922b5da97ce6ece57f052245" name="gga77a60c635f64412b0e4adb5d0337f5a1adc39f393922b5da97ce6ece57f052245"></a>MXC_I2C_EVT_MASTER_RD&#160;</td><td class="fielddoc"><p >requesting a read from the slave. </p>
<p >A slave address match occurred with the master </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1a50b627c766cac2ce3c84dceecc51016f" name="gga77a60c635f64412b0e4adb5d0337f5a1a50b627c766cac2ce3c84dceecc51016f"></a>MXC_I2C_EVT_RX_THRESH&#160;</td><td class="fielddoc"><p >threshold level. </p>
<p >The receive FIFO contains more bytes than its </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1a669bad0d4247e27554a95312c5446dcc" name="gga77a60c635f64412b0e4adb5d0337f5a1a669bad0d4247e27554a95312c5446dcc"></a>MXC_I2C_EVT_TX_THRESH&#160;</td><td class="fielddoc"><p >threshold level. </p>
<p >The transmit FIFO contains fewer bytes than its </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1ab28d7181208b9d2d1155496f9259809b" name="gga77a60c635f64412b0e4adb5d0337f5a1ab28d7181208b9d2d1155496f9259809b"></a>MXC_I2C_EVT_TRANS_COMP&#160;</td><td class="fielddoc"><p >The transaction has ended. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1ac3eab8ca5b105b7b0ee5f695953dd30a" name="gga77a60c635f64412b0e4adb5d0337f5a1ac3eab8ca5b105b7b0ee5f695953dd30a"></a>MXC_I2C_EVT_UNDERFLOW&#160;</td><td class="fielddoc"><p >transmit FIFO was empty. </p>
<p >The master has attempted a read when the </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77a60c635f64412b0e4adb5d0337f5a1abcee3c54a0a5c9ffc955221da2d69c5b" name="gga77a60c635f64412b0e4adb5d0337f5a1abcee3c54a0a5c9ffc955221da2d69c5b"></a>MXC_I2C_EVT_OVERFLOW&#160;</td><td class="fielddoc"><p >FIFO was already full. </p>
<p >The master has written data when the receive </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga92648a55c0b2b94b99e81fc1b2fb4f48" name="ga92648a55c0b2b94b99e81fc1b2fb4f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92648a55c0b2b94b99e81fc1b2fb4f48">&#9670;&nbsp;</a></span>MXC_I2C_AbortAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_AbortAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort any asynchronous requests in progress. </p>
<p >Abort any asynchronous requests in progress. Any callbacks associated with the active transaction will be executed to indicate when the transaction has been terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3fc7633faccfdc8bfd2e662155d4190" name="gaf3fc7633faccfdc8bfd2e662155d4190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3fc7633faccfdc8bfd2e662155d4190">&#9670;&nbsp;</a></span>MXC_I2C_AsyncHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_AsyncHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The processing function for asynchronous transactions. </p>
<p >When using the asynchronous functions, the application must call this function periodically. This can be done from within the I2C interrupt handler or periodically by the application if I2C interrupts are disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb51adbf4b889de2aa48892aa525dfc5" name="gadb51adbf4b889de2aa48892aa525dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb51adbf4b889de2aa48892aa525dfc5">&#9670;&nbsp;</a></span>MXC_I2C_AsyncStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_AsyncStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop any asynchronous requests in progress. </p>
<p >Stop any asynchronous requests in progress. Any callbacks associated with the active transaction will be NOT executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15ad14f32660186f7ba6cf1b4bdd3068" name="ga15ad14f32660186f7ba6cf1b4bdd3068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ad14f32660186f7ba6cf1b4bdd3068">&#9670;&nbsp;</a></span>MXC_I2C_ClearFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_ClearFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the Interrupt Flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">flags0</td><td>Flags to clear in interrupt register intfl0. </td></tr>
    <tr><td class="paramname">flags1</td><td>Flags to clear in interrupt register intfl1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e05ef461feb962f032ff7a4b2a35456" name="ga4e05ef461feb962f032ff7a4b2a35456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e05ef461feb962f032ff7a4b2a35456">&#9670;&nbsp;</a></span>MXC_I2C_ClearRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_ClearRXFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and discards all bytes currently in the receive FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ac5558ec91a3d434f13b67596cd9864" name="ga5ac5558ec91a3d434f13b67596cd9864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ac5558ec91a3d434f13b67596cd9864">&#9670;&nbsp;</a></span>MXC_I2C_ClearTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_ClearTXFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and discards all bytes currently in the transmit FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63aab1fcc4e60971532b8b6dcf9f2037" name="ga63aab1fcc4e60971532b8b6dcf9f2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63aab1fcc4e60971532b8b6dcf9f2037">&#9670;&nbsp;</a></span>MXC_I2C_DisableGeneralCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_DisableGeneralCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents the slave from responding to the general call address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc27ac288f41d583048b9f90cf8aebd9" name="gadc27ac288f41d583048b9f90cf8aebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc27ac288f41d583048b9f90cf8aebd9">&#9670;&nbsp;</a></span>MXC_I2C_DisableInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_DisableInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">flags0</td><td>Interrupts to be disabled in int-&gt;en0 </td></tr>
    <tr><td class="paramname">flags1</td><td>Interrupts to be disabled in int-&gt;en1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d80b18ac960c15b428533c3a029cec7" name="ga1d80b18ac960c15b428533c3a029cec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d80b18ac960c15b428533c3a029cec7">&#9670;&nbsp;</a></span>MXC_I2C_DisablePreload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_DisablePreload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the slave preload mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada949222dbe550f528f7a52fd19b7723" name="gada949222dbe550f528f7a52fd19b7723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada949222dbe550f528f7a52fd19b7723">&#9670;&nbsp;</a></span>MXC_I2C_DMACallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_DMACallback </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The processing function for DMA transactions. </p>
<p >When using the DMA functions, the application must call this function periodically. This can be done from within the DMA Interrupt Handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>DMA channel </td></tr>
    <tr><td class="paramname">error</td><td>Error status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53bfbcf321baaf94f79712c2f1e422a5" name="ga53bfbcf321baaf94f79712c2f1e422a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53bfbcf321baaf94f79712c2f1e422a5">&#9670;&nbsp;</a></span>MXC_I2C_EnableGeneralCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_EnableGeneralCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the slave to respond to the general call address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3191ddeb97b19c0c103ad9e78c1f12c9" name="ga3191ddeb97b19c0c103ad9e78c1f12c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3191ddeb97b19c0c103ad9e78c1f12c9">&#9670;&nbsp;</a></span>MXC_I2C_EnableInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_EnableInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">flags0</td><td>Interrupts to be enabled in int-&gt;en0 </td></tr>
    <tr><td class="paramname">flags1</td><td>Interrupts to be enabled in int-&gt;en1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7915d0d8a68ee5dc3c6bdf3becd8a62" name="gae7915d0d8a68ee5dc3c6bdf3becd8a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7915d0d8a68ee5dc3c6bdf3becd8a62">&#9670;&nbsp;</a></span>MXC_I2C_EnablePreload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_EnablePreload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the slave preload mode. </p>
<p >Use this mode to preload the slave TX FIFO with data that can be sent when the slave is addressed for a read operation without software intervention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga913e7debd6310460beba186cd4eb2712" name="ga913e7debd6310460beba186cd4eb2712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913e7debd6310460beba186cd4eb2712">&#9670;&nbsp;</a></span>MXC_I2C_GetClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetClockStretching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if clock stretching has been enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if clock stretching is disabled, non-zero otherwise </dd></dl>

</div>
</div>
<a id="ga9b9c710601045d2b56aa72a9d245582f" name="ga9b9c710601045d2b56aa72a9d245582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b9c710601045d2b56aa72a9d245582f">&#9670;&nbsp;</a></span>MXC_I2C_GetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>flags0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>flags1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the presently set interrupt flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">flags0</td><td>Pointer to variable to store interrupt status for interrupt register intfl0. </td></tr>
    <tr><td class="paramname">flags1</td><td>Pointer to variable to store interrupt status for interrupt register intfl1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0b7dced5e6c9a0cb98c9f4996bd221e" name="gab0b7dced5e6c9a0cb98c9f4996bd221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b7dced5e6c9a0cb98c9f4996bd221e">&#9670;&nbsp;</a></span>MXC_I2C_GetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the frequency of the I2C interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The I2C bus frequency in Hertz </dd></dl>

</div>
</div>
<a id="ga102491bfd8c3c184104b72f9818049d3" name="ga102491bfd8c3c184104b72f9818049d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102491bfd8c3c184104b72f9818049d3">&#9670;&nbsp;</a></span>MXC_I2C_GetRXFIFOAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetRXFIFOAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes currently available in the receive FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available. </dd></dl>

</div>
</div>
<a id="gaaf888560e606dd4cb1fe3bab90c06756" name="gaaf888560e606dd4cb1fe3bab90c06756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf888560e606dd4cb1fe3bab90c06756">&#9670;&nbsp;</a></span>MXC_I2C_GetRXThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetRXThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current receive threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The receive threshold value (in bytes). </dd></dl>

</div>
</div>
<a id="ga2be643c85c4916d9a8c2d3275ff38a30" name="ga2be643c85c4916d9a8c2d3275ff38a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be643c85c4916d9a8c2d3275ff38a30">&#9670;&nbsp;</a></span>MXC_I2C_GetTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int MXC_I2C_GetTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current I2C timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current timeout in uS </dd></dl>

</div>
</div>
<a id="ga2ae59db133ca586c021568cb92a0b1bc" name="ga2ae59db133ca586c021568cb92a0b1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae59db133ca586c021568cb92a0b1bc">&#9670;&nbsp;</a></span>MXC_I2C_GetTXFIFOAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetTXFIFOAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of free space available in the transmit FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available. </dd></dl>

</div>
</div>
<a id="gae3f521e2c112fee74366b5be8af48662" name="gae3f521e2c112fee74366b5be8af48662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f521e2c112fee74366b5be8af48662">&#9670;&nbsp;</a></span>MXC_I2C_GetTXThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_GetTXThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current transmit threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transmit threshold value (in bytes). </dd></dl>

</div>
</div>
<a id="gaffa36a7ab08e0f222bb7a9c305d2eca6" name="gaffa36a7ab08e0f222bb7a9c305d2eca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffa36a7ab08e0f222bb7a9c305d2eca6">&#9670;&nbsp;</a></span>MXC_I2C_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>masterMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slaveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and enable I2C peripheral. </p>
<dl class="section note"><dt>Note</dt><dd>This function sets the I2C Speed to 100kHz, if another speed is desired use the <a class="el" href="group__i2c.html#ga77c6eb650f273bdd2ecd472d214a4457" title="Set the frequency of the I2C interface.">MXC_I2C_SetFrequency()</a> function to set it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">masterMode</td><td>Whether to put the device in master or slave mode. Use non-zero for master mode, and zero for slave mode. </td></tr>
    <tr><td class="paramname">slaveAddr</td><td>7-bit or 10-bit address to use when in slave mode. This parameter is ignored when masterMode is non-zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga6609599fffe5affbd589dd81f11aeed2" name="ga6609599fffe5affbd589dd81f11aeed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6609599fffe5affbd589dd81f11aeed2">&#9670;&nbsp;</a></span>MXC_I2C_MasterTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_MasterTransaction </td>
          <td>(</td>
          <td class="paramtype">mxc_i2c_req_t *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blocking I2C master transaction. </p>
<p >Performs a blocking I2C master transaction. These actions will be performed:</p><ol type="1">
<li>If necessary, generate a start condition on the bus.</li>
<li>Send the slave address with the low bit set to 0 (indicating a write).</li>
<li>Transmit req-&gt;tx_len bytes of req-&gt;tx_buff.</li>
<li>Generate a repeated start condition on the bus.</li>
<li>Send the slave address with the low bit set to 1 (indicating a read).</li>
<li>Receive req-&gt;rx_len bytes into req-&gt;rx_buf, acknowledging each byte.</li>
<li>Generate a stop (or repeated start) condition on the bus. Steps 3-6 will be skipped if req-&gt;tx_len and req-&gt;rx_len are both 0. Steps 2-4 will be skipped if req-&gt;tx_len equals 0. Steps 4-6 will be skipped if req-&gt;rx_len equals 0.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Pointer to details of the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all bytes are acknowledged, 1 if any byte transmitted is not acknowledged, negative if error. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error return codes. </dd></dl>

</div>
</div>
<a id="ga757bef5ee0c5cae8ba88370746ca3715" name="ga757bef5ee0c5cae8ba88370746ca3715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga757bef5ee0c5cae8ba88370746ca3715">&#9670;&nbsp;</a></span>MXC_I2C_MasterTransactionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_MasterTransactionAsync </td>
          <td>(</td>
          <td class="paramtype">mxc_i2c_req_t *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking I2C master transaction. </p>
<p >Performs a non-blocking I2C master transaction. These actions will be performed:</p><ol type="1">
<li>If necessary, generate a start condition on the bus.</li>
<li>Send the slave address with the low bit set to 0 (indicating a write).</li>
<li>Transmit req-&gt;tx_len bytes of req-&gt;tx_buff.</li>
<li>Generate a repeated start condition on the bus.</li>
<li>Send the slave address with the low bit set to 1 (indicating a read).</li>
<li>Receive req-&gt;rx_len bytes into req-&gt;rx_buf, acknowledging each byte.</li>
<li>Generate a stop (or repeated start) condition on the bus.</li>
<li>Execute req-&gt;callback to indicate the transaction is complete. Steps 3-6 will be skipped if tx_len and rx_len are both 0. Steps 2-4 will be skipped if tx_len equals 0. Steps 4-6 will be skipped if rx_len equals 0.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__i2c.html#gaf3fc7633faccfdc8bfd2e662155d4190" title="The processing function for asynchronous transactions.">MXC_I2C_AsyncHandler()</a> must be called periodically for this function to operate properly. Ideally from the I2C ISR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Pointer to details of the transaction. The memory used by this parameter must remain available until the callback is executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gab59f39c18ce6f0cb09703515734d6422" name="gab59f39c18ce6f0cb09703515734d6422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab59f39c18ce6f0cb09703515734d6422">&#9670;&nbsp;</a></span>MXC_I2C_MasterTransactionDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_MasterTransactionDMA </td>
          <td>(</td>
          <td class="paramtype">mxc_i2c_req_t *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking I2C transaction using DMA for reduced time in the ISR. </p>
<p >Performs a non-blocking I2C transaction. These actions will be performed:</p><ol type="1">
<li>If necessary, generate a start condition on the bus.</li>
<li>Send the slave address with the low bit set to 0 (indicating a write).</li>
<li>Transmit req-&gt;tx_len bytes of req-&gt;tx_buff.</li>
<li>Generate a repeated start condition on the bus.</li>
<li>Send the slave address with the low bit set to 1 (indicating a read).</li>
<li>Receive req-&gt;rx_len bytes into req-&gt;rx_buf, acknowledging each byte.</li>
<li>Generate a stop (or repeated start) condition on the bus.</li>
<li>Execute req-&gt;callback to indicate the transaction is complete. Steps 3-6 will be skipped if tx_len and rx_len are both 0. Steps 2-4 will be skipped if tx_len equals 0. Steps 4-6 will be skipped if rx_len equals 0.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__i2c.html#gaf3fc7633faccfdc8bfd2e662155d4190" title="The processing function for asynchronous transactions.">MXC_I2C_AsyncHandler()</a> must be called periodically for this function to operate properly. Ideally from the I2C ISR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Pointer to details of the transaction. The memory used by this parameter must remain available until the callback is executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gab1ffe81c19cde38ab2d4e0637e72a6be" name="gab1ffe81c19cde38ab2d4e0637e72a6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ffe81c19cde38ab2d4e0637e72a6be">&#9670;&nbsp;</a></span>MXC_I2C_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from the I2C bus. </p>
<p >Read multiple byte from the I2C bus. This function assumes the I2C bus is already in the proper state (i.e. a start condition has already been generated and the bus is in the read phase of an I2C transaction).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer to read the data into. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to read. On return from the function, this will be set to the number of bytes actually received. </td></tr>
    <tr><td class="paramname">ack</td><td>Whether or not to acknowledge the last byte once it is received. All previous bytes will be acknowledged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga89e49207ae370498dde9d6c4d4165ca1" name="ga89e49207ae370498dde9d6c4d4165ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89e49207ae370498dde9d6c4d4165ca1">&#9670;&nbsp;</a></span>MXC_I2C_ReadByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_ReadByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from the I2C bus. </p>
<p >Read a single byte from the I2C bus. This function assumes the I2C bus is already in the proper state (i.e. a start condition has already been generated and the bus is in the read phase of an I2C transaction). If the FIFO is empty, this function will return E_UNDERFLOW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to the byte to read into. </td></tr>
    <tr><td class="paramname">ack</td><td>Whether or not to acknowledge the byte once received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga01baf34328478818eb530a0942050593" name="ga01baf34328478818eb530a0942050593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01baf34328478818eb530a0942050593">&#9670;&nbsp;</a></span>MXC_I2C_ReadByteInteractive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_ReadByteInteractive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c.html#ga85bcf9166313c7a5abe995f795bdffe1">mxc_i2c_getAck_t</a>&#160;</td>
          <td class="paramname"><em>getAck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from the I2C bus. </p>
<p >Read a single byte from the I2C bus. After the byte is received, the provided callback will be used to determine if the byte should be acknowledged or not before continuing with the rest of the transaction. This function assumes the I2C bus is already in the proper state (i.e. a start condition has already been generated and the bus is in the read phase of an I2C transaction). This function must be called with clock stretching enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to the byte to read into. </td></tr>
    <tr><td class="paramname">getAck</td><td>A function to be called to determine whether or not to acknowledge the byte once received. A non-zero return value will acknowledge the byte. If this parameter is set to NULL or its return value is 0, the byte received will not be acknowledged (i.e., it will be NACKed).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gafe47d2f744cd5cc0e29b1193d6e634fe" name="gafe47d2f744cd5cc0e29b1193d6e634fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe47d2f744cd5cc0e29b1193d6e634fe">&#9670;&nbsp;</a></span>MXC_I2C_ReadRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_ReadRXFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads bytes from the receive FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer to read the data into. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read. </dd></dl>

</div>
</div>
<a id="ga2f8dfe0eeb7a171a932db7a494aec59f" name="ga2f8dfe0eeb7a171a932db7a494aec59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8dfe0eeb7a171a932db7a494aec59f">&#9670;&nbsp;</a></span>MXC_I2C_ReadRXFIFODMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_ReadRXFIFODMA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c.html#gaeebe328315d28a4364eeb630b66ef738">mxc_i2c_dma_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads bytes from the receive FIFO using DMA for longer reads. </p>
<dl class="section note"><dt>Note</dt><dd>The operation is not complete until the callback has been called</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer to read the data into. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call when the read is complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return values. </dd></dl>

</div>
</div>
<a id="gad4b8d13c97bf73d1e4c0ee5e631d0f7f" name="gad4b8d13c97bf73d1e4c0ee5e631d0f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4b8d13c97bf73d1e4c0ee5e631d0f7f">&#9670;&nbsp;</a></span>MXC_I2C_ReadyForSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_ReadyForSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given I2C bus can be placed in sleep more. </p>
<p >This functions checks to see if there are any on-going I2C transactions in progress. If there are transactions in progress, the application should wait until the I2C bus is free before entering a low-power state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_x_c___error___codes.html#gaa1f0dfda864fa9d2630645f233e1fdb4">E_NO_ERROR</a> if ready, and non-zero if busy or error. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error return codes. </dd></dl>

</div>
</div>
<a id="gab4e7832da2a21d8b456af63e24ce36ca" name="gab4e7832da2a21d8b456af63e24ce36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4e7832da2a21d8b456af63e24ce36ca">&#9670;&nbsp;</a></span>MXC_I2C_Recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Recover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>retries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to recover the I2C bus, ensuring the I2C lines are idle. </p>
<p >Attempts to recover and reset an I2C bus by sending I2C clocks. During each clock cycle, the SDA line is cycled to determine if the master has control of the line. The following steps are performed to create one SCL clock cycle:</p><ol type="1">
<li>Drive SCL low</li>
<li>Verify SCL is low</li>
<li>Drive SDA low</li>
<li>Verify SDA is low</li>
<li>Release SDA allowing it to return high</li>
<li>Verify SDA is high</li>
<li>Release SCL allowing it to return high.</li>
<li>Verify SCL is high If any of the steps fail, the bus is considered to still be busy and the sequence is repeated up to the requested number of times. If all steps succeed, a final stop condition is generated on the I2C bus.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">retries</td><td>Number of times to attempt the clock cycle sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gae0dceaa8c080edde5acf5bece9b054ba" name="gae0dceaa8c080edde5acf5bece9b054ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0dceaa8c080edde5acf5bece9b054ba">&#9670;&nbsp;</a></span>MXC_I2C_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the I2C peripheral. </p>
<dl class="section note"><dt>Note</dt><dd>The peripheral will need to be initialized with <a class="el" href="group__i2c.html#gaffa36a7ab08e0f222bb7a9c305d2eca6" title="Initialize and enable I2C peripheral.">MXC_I2C_Init()</a> before use</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga35511bf2fd8213685ba6202b8b81929b" name="ga35511bf2fd8213685ba6202b8b81929b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35511bf2fd8213685ba6202b8b81929b">&#9670;&nbsp;</a></span>MXC_I2C_SetClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SetClockStretching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables clock stretching by the slave. </p>
<p >Enables or disables clock stretching by the slave. This function has no affect when operating as the master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">enable</td><td>Enables clock stretching if non-zero, disables if zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga77c6eb650f273bdd2ecd472d214a4457" name="ga77c6eb650f273bdd2ecd472d214a4457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c6eb650f273bdd2ecd472d214a4457">&#9670;&nbsp;</a></span>MXC_I2C_SetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SetFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the frequency of the I2C interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">hz</td><td>The desired frequency in Hertz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative if error, otherwise actual speed set. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error return codes. </dd></dl>

</div>
</div>
<a id="ga0f96f30ffcaf5f775773e36faac3b1e3" name="ga0f96f30ffcaf5f775773e36faac3b1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f96f30ffcaf5f775773e36faac3b1e3">&#9670;&nbsp;</a></span>MXC_I2C_SetRXThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SetRXThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the receive threshold level. </p>
<p >When operating as a master, the function sets the receive threshold level for when the master should unload the receive FIFO. Smaller values may consume more CPU cycles, but decrease the chances of the master delaying the generation of I2C bus clocks because it has no room in the FIFO to receive data. Larger values may consume fewer CPU cycles, but risk delays of the I2C clock. When operating as a slave, this function sets the number of bytes the slave transaction functions should receive before issuing a call to their callback function. Smaller values may consume more CPU cycles, but reduce the risk of missing data from the master due to the recieve FIFO being full. Larger values may reduce the number of CPU cycles, but may cause bytes sent from the master to be missed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">numBytes</td><td>The threshold level to set. This value must be between 0 and 8 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga4c032adb3aca741cb77d4c5e14d65e60" name="ga4c032adb3aca741cb77d4c5e14d65e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c032adb3aca741cb77d4c5e14d65e60">&#9670;&nbsp;</a></span>MXC_I2C_SetSlaveAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SetSlaveAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave address for I2C instances acting as slaves on the bus. </p>
<dl class="section note"><dt>Note</dt><dd>Set idx to zero, multiple I2C instances acting as slaves on the bus is not yet supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">slaveAddr</td><td>7-bit or 10-bit address to use when in slave mode. This parameter is ignored when masterMode is non-zero. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the I2C slave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gaae88d5d2cf476809b522728a0c0d119f" name="gaae88d5d2cf476809b522728a0c0d119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae88d5d2cf476809b522728a0c0d119f">&#9670;&nbsp;</a></span>MXC_I2C_SetTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MXC_I2C_SetTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I2C Timeout. </p>
<p >The I2C timeout determines the amount of time the master will wait while the slave is stretching the clock, and the amount of time the slave will stretch the clock while waiting for software to unload the fifo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in uS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gacbb55e2af2b42c66e9da1d12c71f8d2c" name="gacbb55e2af2b42c66e9da1d12c71f8d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb55e2af2b42c66e9da1d12c71f8d2c">&#9670;&nbsp;</a></span>MXC_I2C_SetTXThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SetTXThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the transmit threshold level. </p>
<p >When operating as a master, the function sets the transmit threshold level for when the master should add additional bytes to the transmit FIFO. Larger values may consume more CPU cycles, but decrease the chances of the master delaying the generation of I2C bus clocks because it has no data in the FIFO to transmit. Smaller values may consume fewer CPU cycles, but risk delays of the I2C clock. When operating as a slave, this function sets the number of bytes the slave transaction functions should transmit before issuing a call to their callback function. Larger values may consume more CPU cycles, but reduce the risk of not having data ready when the master requests it. Smaller values may reduce the number of CPU cycles, but may cause the master to read from an empty FIFO. (The master will read 0xFF in this case.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">numBytes</td><td>The threshold level to set. This value must be between 0 and 8 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga98e85aeb2f25b27b1049b8519dad9276" name="ga98e85aeb2f25b27b1049b8519dad9276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e85aeb2f25b27b1049b8519dad9276">&#9670;&nbsp;</a></span>MXC_I2C_Shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable and shutdown I2C peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga037f5f639895fb5305d05f1f8a975ddb" name="ga037f5f639895fb5305d05f1f8a975ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga037f5f639895fb5305d05f1f8a975ddb">&#9670;&nbsp;</a></span>MXC_I2C_SlaveTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SlaveTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c.html#ga5ece424b8dcaa21b765af1e9b84148d7">mxc_i2c_slave_handler_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blocking I2C slave transaction. </p>
<p >Performs a blocking I2C slave transaction. This function will block until a complete transaction with this slave has been performed. A transaction begins with the master addressing the slave and ends with a repeated start condition, a stop condition, or a bus error. The provided callback function will be called for these events:</p><ul>
<li>A slave address match occurs with the master requesting a write to the slave.</li>
<li>A slave address match occurs with the master requesting a read from the slave.</li>
<li>The receive FIFO crosses the set threshold (see <a class="el" href="group__i2c.html#ga0f96f30ffcaf5f775773e36faac3b1e3" title="Set the receive threshold level.">MXC_I2C_SetRXThreshold()</a>). The callback code should unload the receive FIFO (see MXC_I2C_ReadFIFO()) to allow the master to send more data. The return value of the callback function will determine if the last byte received should be acknowledged or not. Return 0 to acknowledge, non-zero to not acknowledge.</li>
<li>The transmit FIFO crosses the set threshold (see <a class="el" href="group__i2c.html#gacbb55e2af2b42c66e9da1d12c71f8d2c" title="Set the transmit threshold level.">MXC_I2C_SetTXThreshold()</a>). If the master is expected to read more data from this slave, the callback code should add data to the transmit FIFO (see MXC_I2C_WriteFIFO()).</li>
<li>The transaction ends. If the master was writing to the slave, the receive FIFO may still contain valid data that needs to be retreived (see MXC_I2C_ReadFIFO()).</li>
<li>The transmit FIFO underflows because the master requests data when the transmit FIFO is empty.</li>
<li>The receive FIFO overflows because the master writes data while the receive FIFO was full.</li>
</ul>
<p >If clock stretching is disabled, careful attention must be paid to the timing of the callback to avoid losing data on write or unintentionally nacking a read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be called when an I2C event occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga71992198c387effdb887ace75d2b40c7" name="ga71992198c387effdb887ace75d2b40c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71992198c387effdb887ace75d2b40c7">&#9670;&nbsp;</a></span>MXC_I2C_SlaveTransactionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_SlaveTransactionAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c.html#ga5ece424b8dcaa21b765af1e9b84148d7">mxc_i2c_slave_handler_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking I2C slave transaction. </p>
<p >Performs a non-blocking I2C slave transaction. This request will remain active until a complete transaction with this slave has been performed. A transaction begins with the master begins with the master addressing the slave and ends with a repeated start condition, a stop condition, or a bus error. The provided callback function will be called for these events:</p><ul>
<li>A slave address match occurs with the master requesting a write to the slave.</li>
<li>A slave address match occurs with the master requesting a read from the slave.</li>
<li>The receive FIFO crosses the set threshold (see <a class="el" href="group__i2c.html#ga0f96f30ffcaf5f775773e36faac3b1e3" title="Set the receive threshold level.">MXC_I2C_SetRXThreshold()</a>). The callback code should unload the receive FIFO (see MXC_I2C_ReadFIFO()) to allow the master to send more data. The return value of the callback function will determine if the last byte received should be acknowledged or not. Return 0 to acknowledge, non-zero to not acknowledge.</li>
<li>The transmit FIFO crosses the set threshold (see <a class="el" href="group__i2c.html#gacbb55e2af2b42c66e9da1d12c71f8d2c" title="Set the transmit threshold level.">MXC_I2C_SetTXThreshold()</a>). If the master is expected to read more data from this slave, the callback code should add data to the transmit FIFO (see MXC_I2C_WriteFIFO()).</li>
<li>The transaction ends. If the master was writing to the slave, the receive FIFO may still contain valid data that needs to be retreived (see MXC_I2C_ReadFIFO()).</li>
<li>The transmit FIFO underflows because the master requests data when the transmit FIFO is empty.</li>
<li>The receive FIFO overflows because the master writes data while the receive FIFO was full.</li>
</ul>
<p >If clock stretching is disabled, careful attention must be paid to the timing of the callback to avoid losing data on write or unintentionally nacking a read.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__i2c.html#gaf3fc7633faccfdc8bfd2e662155d4190" title="The processing function for asynchronous transactions.">MXC_I2C_AsyncHandler()</a> must be called peridocally for this function to operate properly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be called when an I2C event occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="gabe385d2386e3828c8ee1843eefb2bdb8" name="gabe385d2386e3828c8ee1843eefb2bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe385d2386e3828c8ee1843eefb2bdb8">&#9670;&nbsp;</a></span>MXC_I2C_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a start (or repeated start) condition on the I2C bus. </p>
<p >Generate a start (or repeated start) condition on the I2C bus. This function may opt to delay the actual generation of the start condition until data is actually transferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga4b23466f882ed573b26bf35fae91684f" name="ga4b23466f882ed573b26bf35fae91684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b23466f882ed573b26bf35fae91684f">&#9670;&nbsp;</a></span>MXC_I2C_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a stop condition on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Fail, see <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return codes. </dd></dl>

</div>
</div>
<a id="ga9ef10e74237bebc99697454754fa2cc5" name="ga9ef10e74237bebc99697454754fa2cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ef10e74237bebc99697454754fa2cc5">&#9670;&nbsp;</a></span>MXC_I2C_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to the I2C bus. </p>
<p >Write multiple bytes to the I2C bus. This function assumes the I2C bus is already in the proper state (i.e. a start condition has already been generated and the bus is in the write phase of an I2C transaction).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer containing the bytes to transmit. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to write. On return from the function, this will be set to the number of bytes actually transmitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all bytes are acknowledged, 1 if any byte transmitted is not acknowledged, negative if error. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error return codes. </dd></dl>

</div>
</div>
<a id="ga08ce8ba5d7da2e0bcb768d3883d01388" name="ga08ce8ba5d7da2e0bcb768d3883d01388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08ce8ba5d7da2e0bcb768d3883d01388">&#9670;&nbsp;</a></span>MXC_I2C_WriteByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_WriteByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte to the I2C bus. </p>
<p >Write a single byte to the I2C bus. This function assumes the I2C bus is already in the proper state (i.e. a start condition has already been generated and the bus is in the write phase of an I2C transaction). If any bytes are pending in the FIFO (i.e. in the case of clock stretching), this function will return E_OVERFLOW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">byte</td><td>The byte to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if byte is acknowledged, 1 if not acknowledged, negative if error. See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for the list of error return codes. </dd></dl>

</div>
</div>
<a id="gab0cf9728326a2b8ecded92970c4203a6" name="gab0cf9728326a2b8ecded92970c4203a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0cf9728326a2b8ecded92970c4203a6">&#9670;&nbsp;</a></span>MXC_I2C_WriteTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_WriteTXFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads bytes into the transmit FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer containing the bytes to write </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually written. </dd></dl>

</div>
</div>
<a id="gaff38fb85b10d703e0013550ea990bf5c" name="gaff38fb85b10d703e0013550ea990bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff38fb85b10d703e0013550ea990bf5c">&#9670;&nbsp;</a></span>MXC_I2C_WriteTXFIFODMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MXC_I2C_WriteTXFIFODMA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__registers.html#structmxc__i2c__regs__t">mxc_i2c_regs_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c.html#gaeebe328315d28a4364eeb630b66ef738">mxc_i2c_dma_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads bytes into the transmit FIFO using DMA for longer writes. </p>
<dl class="section note"><dt>Note</dt><dd>The operation is not complete until the callback has been called </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to I2C registers (selects the I2C block used.) </td></tr>
    <tr><td class="paramname">bytes</td><td>The buffer containing the bytes to write </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call when the read is complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___m_x_c___error___codes.html">Error Codes</a> for a list of return values </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 12 2023 16:48:34 for MAX32680 Peripheral Driver API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
