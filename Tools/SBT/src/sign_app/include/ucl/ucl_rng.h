/*===========================================================================
 *
 * ucl_rng.h
 *
 *==========================================================================*/
/*===========================================================================
 *
 * Copyright Â© 2009 Innova Card. All Rights Reserved. Do not disclose.
 *
 * This software is the confidential and proprietary information of
 * Innova Card ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered
 * into with Innova Card.
 *
 * Innova Card makes no representations or warranties about the suitability of
 * the software, either express or implied, including but not limited to
 * the implied warranties of merchantability, fitness for a particular purpose,
 * or non-infrigement. Innova Card shall not be liable for any damages suffered
 * by licensee as the result of using, modifying or distributing this software
 * or its derivatives.
 *
 *==========================================================================*/
/*===========================================================================
 *
 * Purpose: Random Number Generator Interface
 *
 *==========================================================================*/
#ifndef UCL_RNG_H_
#define UCL_RNG_H_

/** @file ucl_rng.h
 * @defgroup UCL_RNG RNG Interface
 * Interface for Random Number Generator.
 *
 * This interface allows to attach any RNG for all random needs of the UCL.
 * The default RNG is the hardware USIP&reg; TRNG.
 *
 * @par Header:
 * @link ucl_rng.h ucl_rng.h @endlink
 *
 *
 * @ingroup UCL_RAND
 */

#include "ucl/ucl_trng.h"

#ifdef __cplusplus
extern "C" {
#endif /* _ cplusplus  */

/** <b>Attach</b>.
 * Attach a RNG.
 *
 * @param[in] rng The pointer to the RNG
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 *
 * @ingroup UCL_RNG
 */
int ucl_rng_attach(int (*rng)(u8* rand, u32 rand_byteLen, int option));

/** <b>Detach</b>.
 * Detach the previously attached RNG.
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 *
 * @ingroup UCL_RNG
 */
int ucl_rng_detach(void);

/** <b>Get pointer</b>.
 * Get the pointer of the current RNG.
 *
 * @return A function pointer
 *
 * @ingroup UCL_RNG
 */
void* ucl_rng_getpt(void);

/** <b>RNG Read</b>.
 * Read random octet string using the hardware RNG.
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 * @param[in]  option       A value between:
 *                              @li #UCL_RAND_DEFAULT
 *                              @li #UCL_RAND_NO_NULL
 *
 * by default, this function is called by the ucl_rng_read
 * @return Error code or a positive value equal to @p the generated byte number
 *
 * @retval #UCL_ERROR    in case of error
 *
 * @ingroup UCL_RNG
 */
int ucl_lowlevel_rng_read(u8* rand, u32 rand_byteLen, int option);

/** <b>RNG Read</b>.
 * Read random octet string using the attached RNG.
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 * @param[in]  option       A value between:
 *                              @li #UCL_RAND_DEFAULT
 *                              @li #UCL_RAND_NO_NULL
 *
 * by default, this function calls the ucl_lowlevel_rng_read
 * if the ucl_rng_attach function has been used, this function calls the new RNG function
 *
 * @return Error code or a positive value equal to @p the generated byte number
 *
 * @retval #UCL_ERROR    in case of error
 *
 * @ingroup UCL_RNG
 */
int ucl_rng_read(u8* rand, u32 rand_byteLen, int option);

/** <b>FIPS 140 RNG Read</b>.
 * Read random octet string using the attached RNG.
 * in a FIPS 140 compliant way (being sure the entropy is maximum)
 * it is slower than the ucl_rng_read() function
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 * @param[in]  option       A value between:
 *                              @li #UCL_RAND_DEFAULT
 *                              @li #UCL_RAND_NO_NULL
 *
 * @return Error code or a positive value equal to @p the generated byte number
 *
 * @retval #UCL_ERROR    in case of error
 *
 * @ingroup UCL_RNG
 */
int ucl_fips_rng_read(u8* rand, u32 rand_byteLen, int option);

/** <b>FIPS 140 TRNG health test</b>.
 * test the TRNG health by checking the oscillators are not stuck
 * if the oscillator is stuck, the function shall never return
 * only available on max32550, max32552, max32555, max32560,  max32565, max32566, max32590
 * no parameter
 * @return Error code
 *
 * @retval #UCL_OK   if everything is ok
 *
 * @ingroup UCL_RNG
 */
int test_fips_trng_health(void);

/** <b>FIPS 140 RNG quality testing</b>.
 * FIPS 140 TRNG quality testing
 * testing performed on 20Kbits directly from the TRNG using the FIPS-compliant TRNG access function
 * testing consisting in FIPS 140 max-run test, runs test, poker test
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_ERROR error has occurred
 *
 * @ingroup UCL_RNG
 */
int ucl_fips_rng_stest(void);

/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SHA-256
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sha256_whitening_rng_read(u8* rand, u32 rand_byteLen);

/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SHA-256
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 * @param[in]  option       A value between:
 *                              @li #UCL_RAND_DEFAULT
 *                              @li #UCL_RAND_NO_NULL
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sha256_whitening_rng_read_generic(u8* rand, u32 rand_byteLen, int option);
/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SHA-256
 * no null byte is produced
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sha256_whitening_rng_read_non_zero(u8* rand, u32 rand_byteLen);
/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SHA-256
 * the first byte is not null
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sha256_whitening_rng_read_leading_non_zero(u8* rand, u32 rand_byteLen);

/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SM3
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sm3_whitening_rng_read(u8* rand, u32 rand_byteLen);

/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SM3
 * no null byte is produced
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sm3_whitening_rng_read_non_zero(u8* rand, u32 rand_byteLen);
/** <b>RNG Read with postprocess</b>.
 * Read random octet string using the attached RNG postprocessed with SM3
 * the first byte is not null
 *
 * @param[out] rand         Random octet string
 * @param[in]  rand_byteLen Random byte length
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p rand is the pointer #NULL
 * @retval #UCL_NOP               If @p rand_byteLen = 0
 * @retval #UCL_ERROR if there is no interface to the TRNG
 *
 * @ingroup UCL_RNG
 */
int ucl_sm3_whitening_rng_read_leading_non_zero(u8* rand, u32 rand_byteLen);

/** <b>RNG Read with postprocess</b>.
 * EMV Unpredictable Number generation power down function
 * see EMV bulletin no144 (june-2014)
 * @param[out] q         persistent variant of P, 32 bytes
 * @param[in]  p         pre-image of UN, 32 bytes
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p q is the pointer #NULL
 * @retval #UCL_INVALID_INPUT    If @p p  is the pointer #NULL
 *
 * @ingroup UCL_RNG
 */

// EMV specification bulletin no144, june 2014

#define EMV_TVP_BYTESIZE 8
#define EMV_TID_BYTESIZE 8
#define EMV_IFDSN_BYTESIZE 8
#define EMV_RAND_BYTESIZE 8
#define EMV_AC_BYTESIZE 8
#define EMV_P_BYTESIZE UCL_SHA256_HASHSIZE
#define EMV_Q_BYTESIZE UCL_SHA256_HASHSIZE
#define EMV_UN_BYTESIZE 4

int ucl_emv_unpredictable_number_power_down(u8* q, u8* p);

/** <b>RNG Read</b>.
 * EMV Unpredictable Number generation per transaction P refresh
 * see EMV bulletin no144 (june-2014)
 *
 * @param[in,out] p         pre-image of UN, 32 bytes
 * @param[in]  tvp          time-varying parameter, 8 bytes
 * @param[in]  rand         value from external RNG, 8 bytes, optional (shall be #NULL if not
 * available)
 * @param[in]  ac           application cryptogram, 8 bytes
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p p is the pointer #NULL
 * @retval #UCL_INVALID_INPUT    If @p tvp  is the pointer #NULL
 * @retval #UCL_INVALID_INPUT    If @p ac  is the pointer #NULL
 *
 * @ingroup UCL_RNG
 */
int ucl_emv_unpredictable_number_transaction_p_refresh(u8* p, u8* tvp, u8* rand, u8* ac);

/** <b>RNG Read</b>.
 * EMV Unpredictable Number generation
 * see EMV bulletin no144 (june-2014)
 *
 * @param[out] un           unpredictable number, 4 bytes
 * @param[in] rand        value from external RNG, 8 bytes, optional (shall be #NULL if not
 * available)
 * @param[in]  p         pre-image of UN, 32 bytes
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p un is the pointer #NULL
 * @retval #UCL_INVALID_INPUT     If @p p is the pointer #NULL
 *
 * @ingroup UCL_RNG
 */
int ucl_emv_unpredictable_number_transaction_un_generation(u8* un, u8* rand, u8* p);

/** <b>RNG Read</b>.
 * EMV Unpredictable Number generation power down function
 * see EMV bulletin no144 (june-2014)
 *
 * @param[in,out] q         persistent variant of P, 32 bytes
 * @param[in]  tid         Terminal ID, 8 bytes
 * @param[in]  ifdsn       IFD Serial, 8 bytes
 * @param[in]  tvp          time-varying parameter, 8 bytes
 * @param[in]  rand         value from external RNG, 8 bytes, optional (shall be #NULL if not
 * available)
 * @param[in]  p         pre-image of UN, 32 bytes
 *
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_INVALID_OUTPUT    If @p q is the pointer #NULL
 * @retval #UCL_INVALID_INPUT     If @p tid is the pointer #NULL
 * @retval #UCL_INVALID_INPUT     If @p ifdsn is the pointer #NULL
 * @retval #UCL_INVALID_INPUT     If @p tvp is the pointer #NULL
 * @retval #UCL_INVALID_INPUT     If @p p is the pointer #NULL
 *
 * @ingroup UCL_RNG
 */
int ucl_emv_unpredictable_number_power_up(u8* q, u8* tid, u8* ifdsn, u8* tvp, u8* rand, u8* p);

/** <b>RNG quality testing</b>.
 * TRNG quality testing
 * testing performed on 20Kbits directly from the TRNG or indirectly with SHA-256 post-process
 * testing consisting in FIPS 140 max-run test, runs test, poker test
 * @return Error code
 *
 * @retval #UCL_OK No error occurred
 * @retval #UCL_ERROR error has occurred
 *
 * @ingroup UCL_RNG
 */
int ucl_rng_stest(void);

#ifdef __cplusplus
}
#endif /* _ cplusplus  */

#endif /*UCL_RNG_H_*/
